require(HMMpa)
optim
library(gp)
require(HMMpa)
require(HMMpa)
library(gp)
require(HMMpa)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- exp( x %*% be + 1 )
y <- numeric(n)
for (i in 1:n)  y[i] <- rgenpois(1, mi[i], 0.5)
gp.reg(y, x)
gp.reg2(y, x)
library(gp)
library(HMMpa)
sessioninfo::package_info("gp")
devtools::build_manual("~/R/win-library/4.0/gp", path = "C:/Users/Michail/Desktop/")
library(gp)
sessioninfo::package_info("gp")
devtools::build_manual("~/R/win-library/4.0/gp", path = "C:/Users/Michail/Desktop/")
library(gp)
\ \ y=0,1... \ \ \theta >0, \ \ \phi > 0,
sessioninfo::package_info("gp")
devtools::build_manual("~/R/win-library/4.0/gp", path = "C:/Users/Michail/Desktop/")
library(gp)
library(gp)
sessioninfo::package_info("gp")
devtools::build_manual("~/R/win-library/4.0/gp", path = "C:/Users/Michail/Desktop/")
library(gp)
library(gp)
library(gp)
rewuire
require
install.package("RNGforGPD")
install.packages("RNGforGPD")
library(GenUniGpois(5, -0.4, 100, method = "Inversion"))
GenUniGpois(5, -0.4, 100, method = "Inversion")
library(RNGforGPD)
GenUniGpois(5, -0.4, 100, method = "Inversion")
GenUniGpois(5, 0.4, 100, method = "Inversion")
GenUniGpois
MOM.genpois
RNGforGPD::GenUniGpois
RNGforGPD::GenUniGpois
?RNGforGPD::GenUniGpois
source('C:/Users/Michail/Desktop/Folder/paketo/gp/R/rgp.R')
y <-  rgp(1000, 10, 0.5, method = "Inversion")
gp.mle(y)
gp::gp.mle(y)
y
source('C:/Users/Michail/Desktop/Folder/paketo/gp/R/rgp.R')
y <-  rgp(1000, 10, 0.5, method = "Inversion")
gp.mle(y)
library(gp)
y <-  rgp(1000, 10, 0.5, method = "Inversion")
gp.mle(y)
?RNGforGPD::GenUniGpois
library(gp)
library(gp)
library(gp)
library(gp)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3]
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(1, mi[i], 0.5)
y
GenUniGpois
RNGforGPD::GenUniGpois(theta, lambda, n, details = FALSE, method)
RNGforGPD::GenUniGpois
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3]
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5)[1]
gp.reg(y, x)
gp.reg2(y, x)
rgp(2, mi[i], 0.5, method = "Inversion")
rgp(1, mi[i], 0.5, method = "Inversion")
rgp(2, mi[i], 0.5, method = "Inversion")
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3]
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
gp.reg2(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
gp.reg2(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 3
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 3
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Branching")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 3
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Normal-Approximation")[1]
gp.reg(y, x)
y
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Normal-Approximation")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 3
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Build-Up")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3) * 0.5
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Build-Up")[1]
gp.reg(y, x)
mi
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Chop-Down")[1]
gp.reg(y, x)
y
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Chop-Down")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Chop-Down")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
y
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
mi
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + x[, 3] * be[3] +2
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 3), nrow = n, ncol = 3)
be <- c(1, 1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] - 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
gp.reg2(y, x)
y
mi
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[2]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
n <- 1000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
gp.reg2(y,x)
n <- 2000
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
n <- 500
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
gp.reg2(y, x)
n <- 500
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
gp.reg2(y, x)
n <- 500
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
gp.reg2(y, x)
n <- 500
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
gp.reg2(y, x)
library(gp)
n <- 500
x <- matrix (rnorm(n * 2), nrow = n, ncol = 2)
be <- c(1, 1)
mi <- x[, 1] * be[1] + x[, 2] * be[2] + 1
mi <- exp(mi)
y <- numeric(n)
for (i in 1:n)  y[i] <- rgp(2, mi[i], 0.5, method = "Inversion")[1]
gp.reg(y, x)
be=gp.reg(y,x)$be
est=cbind(1,x)%*%be
plot(y,est)
plot(y,est*2.013995)
cor(y,est*2.013995)
cor(y,est)
est
est=exp(cbind(1,x)%*%be)
plot(y,est*2.013995)
plot(y,est)
be=gp.reg(y,x)$be
be=gp.reg(y,x)
be
library(gp)
library(gp)
sessioninfo::package_info("gp")
devtools::build_manual("~/R/win-library/4.0/gp", path = "C:/Users/Michail/Desktop/")
library(gp)
library(gp)
